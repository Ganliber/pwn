# Format String Exploit

[TOC]



## Basic

* 格式化字符串函数可以接受可变数量的参数，并将**第一个参数作为格式化字符串，根据其来解析之后的参数**



### 格式化字符串函数

- 输入

  ```C
  scanf
  ```

- 输出

  | 函数                      | 基本介绍                               |
  | ------------------------- | -------------------------------------- |
  | printf                    | 输出到 stdout                          |
  | fprintf                   | 输出到指定 FILE 流                     |
  | vprintf                   | 根据参数列表格式化输出到 stdout        |
  | vfprintf                  | 根据参数列表格式化输出到指定 FILE 流   |
  | sprintf                   | 输出到字符串                           |
  | snprintf                  | 输出指定字节数到字符串                 |
  | vsprintf                  | 根据参数列表格式化输出到字符串         |
  | vsnprintf                 | 根据参数列表格式化输出指定字节到字符串 |
  | setproctitle              | 设置 argv                              |
  | syslog                    | 输出日志                               |
  | err, verr, warn, vwarn 等 | 。。。                                 |





### 格式化字符串

这里我们了解一下格式化字符串的格式，其基本格式如下

```C
%[parameter][flags][field width][.precision][length]type
```

每一种 pattern 的含义请具体参考维基百科的[格式化字符串](https://zh.wikipedia.org/wiki/格式化字符串) 。以下几个 pattern 中的对应选择需要重点关注

- parameter
  - n$，获取格式化字符串中的指定参数
- flag
- field width
  - 输出的最小宽度
- precision
  - 输出的最大长度
- length，输出的长度
  - hh，输出一个字节
  - h，输出一个双字节
- type
  - d/i，有符号整数
  - u，无符号整数
  - `x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。
  - o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。
  - s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。
  - c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。
  - p， void * 型，输出对应变量的值。printf("%p",a) 用地址的格式打印变量 a 的值，printf("%p", &a) 打印变量 a 所在的地址。
  - n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。
  - %， '`%`'字面值，不接受任何 flags, width。



### 格式化字符串漏洞原理

在一开始，我们就给出格式化字符串的基本介绍，这里再说一些比较细致的内容。我们上面说，格式化字符串函数是根据格式化字符串函数来进行解析的。**那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制**。比如说'%s'表明我们会输出一个字符串参数。

那么假设，此时我们在编写程序时候，写成了下面的样子

```C
printf("Color %s, Number %d, Float %4.2f");
```

此时我们可以发现我们并没有提供参数，那么程序会如何运行呢？程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为

1. 解析其地址对应的字符串
2. 解析其内容对应的整形值
3. 解析其内容对应的浮点值

对于 2，3 来说倒还无妨，但是对于对于 1 来说，如果提供了一个不可访问地址，比如 0，那么程序就会因此而崩溃。





### 利用

两个利用手段：

- 使程序崩溃，因为 %s 对应的参数地址不合法的概率比较大。
- 查看进程内容，根据 %d，%f 输出了栈上的内容。



#### 程序崩溃

> 总有不合法地址

```python
%s%s%s%s%s%s%s%s%s%s%s%s%s%s
```



#### 泄露内存

> 利用格式化字符串漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作：

- 泄露栈内存
  - 获取某个变量的值
  - 获取某个变量对应地址的内存
- 泄露任意地址内存
  - 利用 GOT 表得到 libc 函数地址，进而获取 libc，进而获取其它 libc 函数地址
  - 盲打，dump 整个程序，获取有用信息。









